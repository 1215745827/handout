---
title: 第二章 | 召回模块核心算法讲解
date: 2020-05-18
categories:
 - 云音乐大数据推荐系统
tags:
 - 推荐系统
---

::: tip

作者：查老师(Charles7c)  
原文：http://charles7c.gitee.io/handout/java/1_intro/day01_%E5%88%9D%E8%AF%86Java.html  
本文为查老师原创文章，商业转载请联系作者获得授权，非商业转载请注明出处。  
本文引用的内容，版权归原作者所有。如有侵权请务必邮件联系我，我会在收到邮件后24小时内进行删除！  

强烈推荐阅读 [《如何有效地报告 Bug》](https://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html)，更好的问题更容易获得帮助。

:::

## 前言

**C：** 在上一章节，我们粗略的认识了一下推荐系统的相关理论基础。而本章节和下章节，我们将会对第一章提到的相关算法进行详细介绍，今天我们主要对召回模块的相关算法进行详解，查老师会带着大家了解一下推荐系统项目中召回模块的算法，详细解释一下协同过滤算法和机器学习之ALS算法的原理。

算法的学习还是有难度的，大家慢慢来吧，不会的地方可以先补补相关基础。

![cloudmusic2_0_0](http://img.muyoung.tech/cloudmusic2_0_0.png)

## 1. 常见召回算法

在上一章节我们就提过了常见的召回模块算法，现在大家再一起回顾一下。

- 基于热门的召回

  筛选用户播放歌曲的行为数据，选取播放次数最多的歌曲作为热门歌曲，为每一个用户进行推荐。

- 基于用户分群的召回

  将用户划分为细粒度群体，为每一个用户群体筛选歌曲播放行为，选取每个群体中的热门歌曲，为每一个用户进行推荐。

  比如按照年龄群体进行划分，85后，90后，95后，00后，.... 或是 10 ~ 18岁，18岁 ~ 25岁，....

- 基于协同过滤的召回

  - **基于用户（user-based）的协同过滤算法** （基于物品的协同过滤和它类似，我们在云音乐推荐系统中任意选择了基于用户的协同过滤）

    其原理很像朋友推荐，比如通过对用户喜欢的`item` 进行分析，发现用户 A 和用户 B 很像（臭味相投），用户 B 喜欢了某个 `item`而用户 A 没有喜欢，那么就把这个 `item` 推荐给用户 A。

  - 基于物品的（item-based）的协同过滤算法

    与基于用户的协同过滤算法非常相似，只是它的出发点是从物品的角度上来考虑。即对比所有数据，发现` itemA` 和 `itemB` 很像(它们被差不多的人喜欢)，那么就把用户 A 喜欢的所有` item`，将这些` item `类似的` item`列表拉出来，作为被推荐候选推荐给用户 A。

  - 基于模型（model-based）的协同过滤算法

    通过一些模型的方法来实现用户对物品的偏好，预测， 涉及的方法较多较杂。

    1. SVD矩阵分解协同过滤算法

    2. LFM隐含语义协同过滤算法

    3. **ALS交替最小二乘协同过滤算法** （Spark对其支持较好，而且大多数的推荐系统用的都是它，所以在云音乐推荐系统中，我们也是使用的它）

## 2. 协同过滤

对于基于热门和基于分群，比较简单，所以我们也不过多介绍，我们主要介绍协同过滤相关的算法。协同过滤依赖用户的行为数据，如果没有用户行为数据，那么将无法使用协同过滤算法。

下面是三种协同过滤方法的核心任务：

- 基于用户的协同过滤：通过用户行为数据求出用户与用户之间的相似度，进而通过相似度计算出用户对所有物品的"感兴趣程度" (user-based)。  
- 基于物品的协同过滤：物品与物品之间的相似度， 进而通过相似度计算出用户对所有物品的"感兴趣程度"(item-based)。  
- 基于模型的协同过滤：中间矩阵， 进而通过中间矩阵计算出用户对所有物品的"感兴趣程度"(model-based)。  

下面我们通过示例详细解释我们要用到的两种协同过滤方法（`user-based`和`ALS`），深入理解协同过滤的核心思想。  

### 2.1 基于用户的协同过滤

#### 2.1.1 工作原理

首先我们来看看 **基于用户的协同过滤** 方法，下面有一张图示可以很好的理解它的原理。

<img src="http://img.muyoung.tech/cloudmusic2_2_1.png" alt="cloudmusic2_2_1" style="zoom:80%;" />

在图中我们可以看到有用户a、b、c，有物品A、B、C、D。其中用户a 喜欢 物品A、 C，用户b 喜欢 物品A、 B。用户c 喜欢 物品A、 C、 D。 用户a 和 c 都喜欢物品A、 C，由此可以得出他们比较相似。 

而在图中，用户a 目前没有标注他 喜欢 物品D，这可能是因为用户a 还没发现 物品D，但不能直接说明他就不喜欢 物品D， 所以在依据用户a 和 用户c 比较相似的情况下， 我们可以将用户c 喜欢的物品D 推荐给用户a。 这个过程就是基于用户的协同过滤。

总结起来，一句通俗的话就是， 首先计算用户之间两两的相似度， 然后通过相似度和相似用户为物品打分的加权来预测目标用户对相应物品的打分。  

#### 2.1.2 案例实现

现在有一个票务类APP，需要我们应用`基于用户的协同过滤`来对`用户1`进行电影推荐，它的实现步骤如下。

**1.获取`user-item稀疏矩阵`** 

首先根据所有用户的行为数据，获取到每个用户对每个物品的喜欢程度评分。当然每个用户不可能对所有物品都进行评分，所以最终可以组织成一个`用户-物品(user-item)`的稀疏矩阵，效果如下。

<img src="http://img.muyoung.tech/cloudmusic2_2_2.png" alt="cloudmusic2_2_2" style="zoom:80%;" />

**2.计算用户之间的相似度** 

在得到如上这个稀疏矩阵之后，我们可以先求出`用户1` 分别与`用户 2`、 `3`、` 4` 的相似度。

如何计算相似度呢？在这个矩阵上，我们可以把每一行的用户评分理解为一个个的向量。例如：用户1理解为向量：`[4.5,3,3.5,0,4,0,0]`，用户2理解为向量：`[0,4.5,5,0,0,4,0]`，这样的话就可以使用`余弦相似度`进行向量之间的相似度求解了。

::: warning 注意

`余弦相似度`是一种度量两个向量间相似度的常用方式， 其他的相似度度量方式还有： `杰卡德相似度`、 `皮尔逊相似度`等等。 余弦相似度在几何上体现为：向量空间内， 两个向量夹角的大小。如果两个向量完全重合， 则相似度为1，如果两个向量垂直， 则相似度为 0。 相似度结果越接近 1， 那么说明两个向量越相似。  

::: 

余弦相似度计算公式为：![cloudmusic2_2_3](http://img.muyoung.tech/cloudmusic2_2_3.png)

公式看的头大？白话理解一下吧，公式中`u`表示的就是`用户1`，`v`表示的就是`用户2`，`ru`表示的是`用户1`的向量，`rv`表示的是`用户2`的向量。`||ru||`表示的是`用户1向量的模`，`||rv||`表示的是`用户2向量的模`。 `rui` 是`用户1` 对 `物品i` 的评分， `rvi`是`用户2` 对 `物品i` 的评分。  如此这般理解后，这公式又可以用下方的形式来表示。

<img src="http://img.muyoung.tech/cloudmusic2_2_4.png" alt="cloudmusic2_2_4" style="zoom:80%;" />

<img src="http://img.muyoung.tech/cloudmusic2_2_5.png" alt="cloudmusic2_2_5" style="zoom:80%;" />

通过两两求相似度之后，我们可以得到如下相似度矩阵。

<img src="http://img.muyoung.tech/cloudmusic2_2_6.png" alt="cloudmusic2_2_6" style="zoom:80%;" />

::: warning 注意

关于向量的点积和求模的相关知识，如果你遗忘太多，或者根本就不会了，可以在后文中看看查老师给你的数学知识补充。还有查老师也通过`scala代码`来实现了一下余弦相似度的计算公式，查老师觉得这有助于你的理解，所以在后文中读读看看吧。  

::: 

**3.计算用户1对夏洛特的预测评分** 

有了相似度以后， 要为`用户 1 `进行最终物品推荐， 是推荐"夏洛特烦恼" 还是"中国机长"，亦或是"普罗米修斯"，这是可以通过加权的方式计算出来的。

具体公式为：![cloudmusic2_2_7](http://img.muyoung.tech/cloudmusic2_2_7.png)

`sim(u,v)`表示`用户1` 与 `用户2` 的相似度， `rui^`表示`用户1`对`物品i`的预测得分， 此时`用户1` 未对`物品i`打过分。 `rvi` 表示`用户2` 对`物品i` 的真实打分。  

比如在例子中预测`用户1` 对电影"夏洛特烦恼"的评分，根据公式计算：

<img src="http://img.muyoung.tech/cloudmusic2_2_8.png" alt="cloudmusic2_2_8" style="zoom:80%;" />

<img src="http://img.muyoung.tech/cloudmusic2_2_9.png" alt="cloudmusic2_2_9" style="zoom:80%;" />

计算完后，再对预测出的评分进行倒排，就可以得出，到底应该为`用户1` 推荐哪部电影了。

::: warning 注意

此处必须理解 **基于用户的协同过滤实际要做的就是为目标用户没有打过分的那部分商品进行预测打分** ， 预测的方式是选取与目标用户最相似的前K个用户，再选取目标用户没有进行过评分的物品n， 再将K个相似用户对n个物品的评分进行加权，就可以得出目标用户对n个物品的预测评分。

推广到全局用户来说， 最初有一个 `user-item稀疏矩阵`， 稀疏的原因是因为`很多用户`对很多`item`都没打过分， 也就是没有产生过行为。协同过滤的目的就是通过一种方法， 来"补全"这个稀疏矩阵，让其变成稠密矩阵，从而对用户进行合理的推荐。  

其实也可以使用每个电影的评分的平均分作为`user-item稀疏矩阵`的填充。

:::

#### 2.1.3 向量知识补充

懂你的查老师知道很多同学长期从事应用开发，早就将数学相关的知识还给了数学老师，所以今天查老师临时兼职你的数学老师，复习下向量的部分运算法则。

- 向量的乘法

  ```mathematica
  向量[1,2,3]  点积  向量[1,2,3]  =  1*1 + 2*2 + 3*3  =  14
  运算法则：两个向量对应位置元素进行相乘，然后相加求和
  ```

- 向量求模

  ```mathematica
  对向量[1,2,3]求模(向量的长度)。 
  模 = sqart(1^2 + 2^2 + 3^2)
  运算法则：对向量中的每一个元素进行平方相加，然后对和进行开平方
  ```

#### 2.1.4 代码实现求余弦相似度

补充了向量的部分运算知识后，懂你的查老师还知道你对那头疼的数学公式还是不太理解，所以又通过`scala`实现了下`余弦相似度`的计算。

::: warning 注意

对`scala语言`不太了解没关系，因为它和`Java`、`C#`、`Python`之类的都很像，再加上查老师的注释，相信你是可以理解的。

::: 

```scala
import scala.collection.mutable.ListBuffer

object cosine_similarity {

  /*
   * 计算余弦相似度
   * v1、v2表示两个参数，此时代表向量1和向量2
   */
  def cosvec(v1: Vector[Double], v2: Vector[Double]) = {
    // 两个向量的点积 / 两个向量各自的模的乘积
    val cos = innerProduct(v1, v2) / (module(v1) * module(v2))
    // 返回cos
    cos
  }  
    
  /*
   * 计算向量的模
   * 运算法则：对向量中的每一个元素进行平方相加，然后对和进行开平方
   */
  def module(vec: Vector[Double]) = {
    // 1.对向量中的每一个元素进行平方相加
    // math.pow(a,b) 此函数用于计算a的b次方 a代表底数 b代表几次方
    // vec.map(math.pow(_,2)) 表示对向量内的每个元素求2次方
    // sum代表返回集合中所有数字元素之和
    // 2.对和进行开平方
    // math.sqart(n) 此函数是用于对n进行开平方
    math.sqart(vec.map(math.pow(_, 2)).sum)
  }

  /*
   * 计算向量的点积
   * 运算法则：两个向量对应位置元素进行相乘，然后相加求和
   */
  def innerProduct(v1: Vector[Double], v2: Vector[Double]) = {
    val listBuffer = ListBuffer[Double]()
    // i和j代表向量1和向量2在遍历过程中的每个位置(索引)
  	// if i == j 表示当向量1的位置和向量2的位置相同时 才会执行循环体内容
    for (i <- 0 until v1.length; j <- 0 until v2.length; if i == j) {
      // 两个向量对应位置的元素进行相乘  并存储到ListBuffer中
      listBuffer.append(v1(i) * v2(j))
    }
    // 对ListBuffer中的所有元素求和 并返回
    listBuffer.sum
  }

  // main方法内编写的是主要的计算过程
  def main(args: Array[String]): Unit = {
    // 用户1向量
    var vec1 = Vector(4.5, 3, 3.5, 0, 4, 0, 0)
    // 用户2向量
    var vec2 = Vector(0, 4.5, 5, 0, 0, 4, 0)
   	// 调用方法，计算余弦相似度
    var similarity = cosvec(vec1,vec2)
    println("vec1与vec2的余弦相似度为：")
    println(similarity)
  }
}
```

### 2.2 ALS算法(交替最小二乘法)

了解完协同过滤的核心思想后， 接下来我们再认识一下 **ALS算法** 。`ALS算法`是2008年以来，很多推荐系统中用的比较多的协同过滤算法， 它已经集成到`Spark`的`Mllib`库中，调用起来非常的方便快捷 。从协同过滤的分类来说，它属于 **基于模型的协同过滤**  ，它的核心思想与 **基于用户的协同过滤** 核心思想一致，同样是对`user-Item稀疏矩阵`进行”填充”，从而获得`User`对所有`Item`的感兴趣程度 ，只是两者使用的方法不同而已。 

它比普通协同过滤的优势在于， 实验中它的结果通常会更加准确一些， 并且它是基于矩阵分解的算法， 再计算过程中， 要比普通协同过滤算法存储的中间数据要少得多， 从而使它的运算速度要快很多。  

#### 2.2.1 ALS原理

`ALS 算法`的原理可以描述为一个机器学习的过程， 回顾机器学习的过程， 首先就是找到损失函数， 然后最优化损失函数。 而 ALS 同样如此。
假设有一批用户行为数据，其中包含`m个User`和`n个Item`，由此构建`user-item稀疏矩阵`，其中的元素表示`第u个User`对`第i个Item`的评分，蓝色为已经评分，灰色为未评分，如下图所示。

![cloudmusic2_2_10](http://img.muyoung.tech/cloudmusic2_2_10.png)

蓝色部分就是训练数据，可以将其想象成一个三元组`<userid,itemid,rating>`， 现在所有的蓝色数据都是这么一个三元组。`ALS` 的做法是将 `U-I 矩阵`进行分解， 分解为 `U-K(User-Embedding_K)` 和 `K-I(Embedding_K-Item) `两个矩阵。 其中 `K` 是一个超参数， 需要自己设置， 它被称为`嵌入矩阵(Embbeding)`， `Embbeding`的维度大小就是 `K`， 通常默认是 `100-200` 这类数值。 分解后的矩阵如下：  

![cloudmusic2_2_11](http://img.muyoung.tech/cloudmusic2_2_11.png)

这两个矩阵相乘， 刚刚好能够得到 `U-I 矩阵`。 而这两个矩阵中， 蓝色的值都是填充的， 并且他们都是 **参数** ， 也就是机器学习中所需要学习的东西。 `ALS` 首先初始化两个矩阵中的参数， 然后再将两个矩阵相乘得到稠密矩阵 `U-I`。

该矩阵与真实的 `U-I 矩阵`进行比较， 因为真实 `U-I 矩阵`中有很多值是空白的， 所以只能选取那部分训练数据来构造损失函数。 损失函数的构造就是训练数据与`稠密的U-I 矩阵`的值求 `RMSE`。 损失函数构造完成后， 使用` ALS算法（交替最小二乘法）`进行损失函数优化， 它和梯度下降法类似， 都是最优化损失函数的方法。

具体做法是先固定住 `U-K 矩阵`，对 `K-I 矩阵`中的参数 求 极值， 然后再固定 `K-I 矩阵`， 对 `U-K 矩阵`中的参数求极值，直到模型参数收敛为止。

**总结起来步骤就是：** 

1. 将`user-item`稀疏矩阵中蓝色的值作为训练集
2. `User-Embedding`，`Embedding-Item`矩阵为稠密矩阵，并且矩阵中所有的值都在机器学习任务中当作参数，需要通过机器学习训练得出。
3. 损失函数由`User-Embedding`，`Embedding-Item`矩阵的点积和训练集的值求RMSE得出
4. 优化方法使用`ALS交替最小二乘法`进行损失函数优化
5. 最终求得`User-Embedding`，`Embedding-Item`矩阵，这样就可以得到稠密的`user-item`矩阵

::: warning 注意

`ALS` 的目的， 就是填充真实的` U-I 矩阵`而已，算法细节如果看不明白可以先略过。知道以下内容即可：`ALS 算法`是通过矩阵分解完成的， 并且是一种机器学习的方法， 它的优势是实验结果准确， 并且相对于传统协同过滤方法， 需要计算的数据量级上有非常大的提升， 运行速度上同理。

:::

#### 2.2.2  协同过滤的评分策略

`User-item矩阵`的评分是主观设定的，我们云音乐推荐系统中的设定是：播放为1分，下载为2分，分享为3分，收藏为4分，最终在全局做一次评分归一化得出最终评分。之所以要进行归一化，是因为像刚才的电影评分，它是显式反馈，是用户主观的打分，而我们的云音乐推荐系统没有此类明确的分数，所以需要对各类隐式反馈进行计算，然后归一化为统一的得分。

例如：一个用户对一首歌曲有播放、下载、分享、收藏这四个行为，那么分数相加后为：1 + 2 + 3 + 4 = 10，经过归一化后将其评分为`0.8`（评分在0 ~ 1之间）。
通常评分策略由懂业务的、模型开发、项目经理等人参与制定，调整评分策略是优化召回算法的一个非常重要的途径。

#### 2.2.3 矩阵知识补充

- 矩阵乘法

  ```mathematica
  [1,2,3
   4,5,6] 
  点积 
  [1,2
   3,4
   5,6]
  =
  [n1,n2,n3,n4]
  n1 = 1*1 + 2*3 + 3*5
  n2 = 1*2 + 2*4 + 3*6
  n3 = 4*1 + 5*3 + 6*5
  n4 = 4*2 + 5*4 + 6*6
  ```


## 后记

**C：** 好了，召回模块中协同过滤算法的 **基于用户的协同过滤** 和 **ALS算法** 就介绍完了，又是一章节的理论，比较枯燥对吧？尤其数学还差点意思的情况下，从阅读到放弃，从关注到取关都是有可能发生的。

查老师在本文中已经提过了，如果你对算法细节理解了，那自然最好，如果没有理解太好，只要抓住查老师每部分最后的算法总结就可以了，它不影响我们在后面章节的代码实现。

下章节，我们还有最后一次算法理论，就可以开始进行环境搭建以及项目实现了！耐心点，同学，我都已经给你摊牌了。

